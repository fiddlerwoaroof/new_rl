#!/usr/bin/env python
from __future__ import division, print_function
import json
import yaml
import collections

def construct_odict(load, node): # from https://gist.github.com/weaver/317164
    """This is the same as SafeConstructor.construct_yaml_omap(),
    except the data type is changed to collections.OrderedDict() and setitem is
    used instead of append in the loop.

    >>> yaml.load('''
    ... !!omap
    ... - foo: bar
    ... - mumble: quux
    ... - baz: gorp
    ... ''')
    OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])

    >>> yaml.load('''!!omap [ foo: bar, mumble: quux, baz : gorp ]''')
    OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])
    """

    omap = collections.OrderedDict()
    yield omap
    if not isinstance(node, yaml.SequenceNode):
        raise yaml.constructor.ConstructorError(
            "while constructing an ordered map",
            node.start_mark,
            "expected a sequence, but found %s" % node.id, node.start_mark
        )
    for subnode in node.value:
        if not isinstance(subnode, yaml.MappingNode):
            raise yaml.constructor.ConstructorError(
                "while constructing an ordered map", node.start_mark,
                "expected a mapping of length 1, but found %s" % subnode.id,
                subnode.start_mark
            )
        if len(subnode.value) != 1:
            raise yaml.constructor.ConstructorError(
                "while constructing an ordered map", node.start_mark,
                "expected a single mapping item, but found %d items" % len(subnode.value),
                subnode.start_mark
            )
        key_node, value_node = subnode.value[0]
        key = load.construct_object(key_node)
        value = load.construct_object(value_node)
        omap[key] = value

yaml.add_constructor(u'tag:yaml.org,2002:omap', construct_odict)


### Represent collections.OrderedDict

def repr_odict(dumper, data):
    """
    >>> data = collections.OrderedDict([('foo', 'bar'), ('mumble', 'quux'), ('baz', 'gorp')])
    >>> yaml.dump(data, default_flow_style=False)
    '!!omap\\n- foo: bar\\n- mumble: quux\\n- baz: gorp\\n'
    >>> yaml.dump(data, default_flow_style=True)
    '!!omap [foo: bar, mumble: quux, baz: gorp]\\n'
    """
    return repr_pairs(dumper, u'tag:yaml.org,2002:omap', data.iteritems())

yaml.add_representer(collections.OrderedDict, repr_odict)

def repr_pairs(dump, tag, sequence, flow_style=None):
    """This is the same code as BaseRepresenter.represent_sequence(),
    but the value passed to dump.represent_data() in the loop is a
    dictionary instead of a tuple."""

    value = []
    node = yaml.SequenceNode(tag, value, flow_style=flow_style)
    if dump.alias_key is not None:
        dump.represented_objects[dump.alias_key] = node
    best_style = True
    for (key, val) in sequence:
        item = dump.represent_data({key: val})
        if not (isinstance(item, yaml.ScalarNode) and not item.style):
            best_style = False
        value.append(item)
    if flow_style is None:
        if dump.default_flow_style is not None:
            node.flow_style = dump.default_flow_style
        else:
            node.flow_style = best_style
    return node

# END https://gist.github.com/weaver/317164

import colorsys

import argparse
parser = argparse.ArgumentParser()
parser.add_argument('file')
parser.add_argument('-r', '--reverse', action='store_true')
args = parser.parse_args()

def convert_color(color):
	r,g,b = color
	r = r/255
	g = g/255
	b = b/255
	print(r,g,b,end='->')
	h,s,v = colorsys.rgb_to_hsv(r,g,b)
	print(h,s,v)
	return h*360, s*255, v*255

if args.reverse:
	def convert_color(color):
		h,s,v = color
		h = h/360
		s = s/255
		v = v/255
		print(h,s,v ,end='->')
		r,g,b = colorsys.hsv_to_rgb(h,s,v)
		print(r,g,b)
		return map(int, (r*255, g*255, b*255))

yml = False
with open(args.file) as f:
	try:
		data = json.load(f, object_hook=collections.OrderedDict, object_pairs_hook=collections.OrderedDict)
	except ValueError:
		yml = True
		f.seek(0,0)
		data = yaml.load(f.read())
		print(data)

	for n in data:
		sub_n = data[n]
		if 'fg' in sub_n:
			sub_n['fg'] = convert_color(sub_n['fg'])
		if 'bg' in sub_n:
			sub_n['bg'] = convert_color(sub_n['bg'])

name, sep, ext = args.file.rpartition('.')
nfile = '%s.conv%s%s' % (name, sep, ext)

with open(nfile, 'w') as f:
	yaml.dump(data, f)
